# -*- coding: utf-8 -*-
"""Feature_Selection_Using_GA_for_HEMALTION2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iZSaDLxLmObF9ugPHGxoQeqfLi65YR9c
"""

import warnings
warnings.filterwarnings("ignore")

import numpy as np
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import cross_val_score
from matplotlib import pyplot as plt
import random

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %ls -l
# %cd 'drive/'

# Commented out IPython magic to ensure Python compatibility.
# %ls -l
# %cd 'MyDrive/'

import pandas as pd

file_path = "/content/drive/MyDrive/HEMALTION2.xlsx"
df = pd.read_excel(file_path)
#df = df.transpose()
#df.to_excel(file_path, index=False)

X = df.iloc[:-1, 1:31]
y = df.iloc[:-1, 31]
print("Shape of X:", X.shape)
print("Shape of y:", y.shape)

y

"""### Population Generation"""

import numpy as np
population = np.random.randint(0, 2, (100,30))
initial_population = population
print(population.shape)
print(population)

"""### Fitness Function"""

def fitness_function(population,X,y):
   fitness = []
   X1 = np.array(X)
   for chromosome in population:
    chr2 = chromosome
    chr1 = [True if chr2[i]==1 else False for i in range(chr2.shape[0])]
    X2 = X1[:,chr1]
    model = DecisionTreeClassifier()
    scores = cross_val_score(model,X1,y,scoring='f1_macro',n_jobs=-1,cv=2)
    fitness.append(scores.mean())
   plt.xlabel('Chromosome Number')
   plt.ylabel('F1 Scores')
   plt.plot(fitness)
   plt.show()
   max1 = np.max(fitness)
   print(max1)
   return fitness

"""### Parent Selection"""

def select_parents(population,fitness_values):
    parents = []
    population_size = len(population)
    for count in range(population_size):
      random_number = np.random.uniform(0, 1)
      individual_number = 0
      for score in fitness_values:
        if(random_number<=score):
          parents.append(population[individual_number])
          break
        individual_number+=1
    return parents

"""### Cross Over"""

def two_point_crossover(parents, probability):
    if len(parents) == 0:
        return []

    random.shuffle(parents)

    no_of_pairs = round(len(parents) * probability / 2)
    chromosome_len = len(parents[0])
    crossover_population = []

    while len(crossover_population) < len(population):
        parent1_index = random.randrange(len(parents))
        parent2_index = random.randrange(len(parents))
        while parent1_index == parent2_index:
            parent2_index = random.randrange(len(parents))

        start = random.randrange(chromosome_len)
        end = random.randrange(chromosome_len)
        if start > end:
            start, end = end, start

        parent1 = parents[parent1_index]
        parent2 = parents[parent2_index]

        child1 = np.concatenate((parent1[0:start], parent2[start:end], parent1[end:]))
        child2 = np.concatenate((parent2[0:start], parent1[start:end], parent2[end:]))

        crossover_population.append(child1)
        crossover_population.append(child2)

    crossover_population = crossover_population[:len(population)]

    return crossover_population

"""### Mutation"""

def mutation(crossover_population):
    for individual in crossover_population:
      index_1 = random.randrange(len(individual))
      index_2 = random.randrange(len(individual))
      while(index_2==index_1 and individual[index_1] != individual[index_2]):
        index_2 = random.randrange(len(individual))
      temp = individual[index_1]
      individual[index_1] = individual[index_2]
      individual[index_2] = temp

    return crossover_population

fitness_values = fitness_function(population, X, y)
max_fitness = []
max_features = []
gen = []
for i in range(15):
   gen.append(i+1)
   print("\n Generation :",i+1)
   parents = select_parents(population, fitness_values)
   crossover_population = two_point_crossover(parents,0.78)
   mutation(crossover_population)
   fitness_values = fitness_function(crossover_population, X, y)
   a = max(fitness_values)
   index_pop = fitness_values.index(a)
   max_fitness.append(a)
   b = crossover_population[index_pop]
   max_features.append(b)

print(len(crossover_population))
print(crossover_population)

